<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <style>
        div.padded {
            padding-top: 0px;
            padding-right: 100px;
            padding-bottom: 0.25in;
            padding-left: 100px;
        }
    </style>
    <title>Yang Huang, Juntao Peng | CS 284A</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>

<body>
    <br />
    <h1 align="middle">Assignment 3: PathTracer</h1>
    <h2 align="middle">Yang Huang, Juntao Peng</h2>

    <div class="padded">
        <p>In assignment 3-2 we first implemented PLACEHOLDER in part 1. Then we chose part 3 as out second part where
            we implemented environment light using uniform sphere sampling and inversion-based importance sampling.</p>
        <h2 align="middle">Part 1: Ray Generation and Intersection</h2>
        <p>Describe what you did in Part 1. etc...</p>
        <div align="center">
            <table style="width=100%">
                <tr>
                    <td align="middle">
                        <img src="images/example_image.png" width="480px" />
                        <figcaption align="middle">Results Caption: my bunny is the bounciest bunny</figcaption>
                </tr>
            </table>
        </div>

        <h2 align="middle">Part 3: Environment Light</h2>
        <p>In part 3 we first write a <code>sample_dir</code> function with which we can trace along the direction of
            a ray until we find the meet point on the environment map. This is achieved by converting global direction
            to theta-phi representation and then convert the angle to environment map using a lerp operation.</p>
        <p>The second task of part 3 is uniform sphere sampling. We write <code>sample_L</code> function with which we
            can sample a uniformly random direction from a hitpoint and find the corresponding xy value on the
            environment map.</p>
        <p>The third task of part 3 is importance sampling using inversion method. We first update the <code>init</code>
            function by storing
            <code>pdf_envmap</code> with the environment map's pixel value and then normalize it. Then we compute the
            marginal cumulative density function in <code>marginal_y</code>, which is a row-wise summation of
            <code>pdf_envmap</code> along the width axis. The last step in the <code>init</code> function is to compute
            <code>cond_y</code> by dividing values in <code>pdf_envmap</code> by the neighbor difference of
            <code>marginal_y</code> (this will give us the true probability of P(y)).
        </p>
        <p>After finishing <code>init</code> function, we need to update <code>sample_L</code> with importance sampling.
            <br>
            1. We first perform a 2D uniform sampling from [0, 1). <br>
            2. Then use the value of <code>sample[1]</code> to
            inversely importance sample from the marginal distribution of y. This is achieved by using
            <code>std::upper_bound</code> to compute the index of the next larger cumulative probability density. <br>
            3. After getting a fixed y-value, we repeat the inversion sampling on the conditional distribution of x
            given y
            to get x-value. <br>
            4. Once we get the xy combination, we lerp it on the environment map, and convert it to the
            world direction. <br>
            5. Finally we set the value of pdf pointer to P(y) * P(x|y) and then multiply it by
            <code>w * h / (2 * PI * PI * sin(theta))</code>.
        </p>
        <div align="center">
            <table style="width=100%">
                <tr>
                    <td align="middle">
                        <img src="images/part3-1.png" width="480px" />
                        <figcaption align="middle">Importance Density of ennis.exr</figcaption>
                </tr>
            </table>
        </div>
        <div align="center">
            <table style="width=100%">
                <tr>
                    <td align="middle">
                        <img src="images/part3-2.png" width="480px" />
                        <figcaption align="middle">Bunny using uniform sphere sampling</figcaption>
                    <td align="middle">
                        <img src="images/part3-3.png" width="480px" />
                        <figcaption align="middle">Bunny using importance sampling</figcaption>
                </tr>
            </table>
        </div>
        <p>
            When rendering our bunny the noise in uniform sphere sampling is higher than the one in importance sampling.
            We
            can see black dots on the surface of the left bunny.
        </p>
        <div align="center">
            <table style="width=100%">
                <tr>
                    <td align="middle">
                        <img src="images/part3-4.png" width="480px" />
                        <figcaption align="middle">Wall-e using uniform sphere sampling</figcaption>
                    <td align="middle">
                        <img src="images/part3-5.png" width="480px" />
                        <figcaption align="middle">Wall-e using importance sampling</figcaption>
                </tr>
            </table>
        </div>
        <p>
            When rendering our Wall-e the noise level between these two methods are closer than that of the bunny's. This is probabily because
            there is more polygons in the dragon mesh so that the ray samples are more likely to hit the model and thus
            gives back a valid radiance from the environment light source.
        </p>
    </div>
</body>

</html>